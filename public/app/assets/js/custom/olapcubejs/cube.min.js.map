{"version":3,"file":"cube.min.js","sources":["../src/console.js","../src/errors.js","../src/Fact.js","../src/Cell.js","../src/EmptyCell.js","../src/Member.js","../src/InputMember.js","../src/SnowflakeBuilder.js","../src/DimensionTable.js","../src/const.js","../src/Tree.js","../src/DimensionTree.js","../src/DimensionHierarchy.js","../src/Tuple.js","../src/Space.js","../src/isPlainObject.js","../src/Cube.js"],"sourcesContent":["const originalConsole = console;\nconst customConsole = {\n\tlog: string => {\n\t\toriginalConsole.log(`[Cube] ${string}`)\n\t},\n\twarn: string => {\n\t\toriginalConsole.warn(`[Cube] ${string}`)\n\t},\n\twarnOnce: (() => {\n\t\tconst memory = {};\n\t\treturn string => {\n\t\t\tif (!memory[string]) {\n\t\t\t\tmemory[string] = true;\n\t\t\t\toriginalConsole.warn(`[Cube] ${string}`)\n\t\t\t}\n\t\t};\n\t})()\n};\nexport default customConsole\n","export class InsufficientRollupData {\n\tconstructor(dimension, id) {\n\t\tthis.message = `Can't add member, member for rollup dimension: ${dimension} with id: ${id} not found`;\n\t}\n}\n\nexport class NotFoundFactId {\n\tconstructor(name) {\n\t\tthis.message = `In fact data, no property was found with the name: ${name}`\n\t}\n}\n\nexport class NotCompletelySpaceException {\n\tconstructor(dimension) {\n\t\tthis.message = `Not completely defined space for added member, not found member for dimension: \"${dimension}\"`;\n\t}\n}\n\nexport class CantAddMemberRollupException {\n\tconstructor(dimension, id) {\n\t\tthis.message = `Can't add member, rollup dimension: ${dimension} with id: ${id} not found`;\n\t}\n}\n\nexport class DimensionException {\n\tconstructor(dimension) {\n\t\tthis.message = `For the name \"${dimension}\" the dimension is already set`;\n\t}\n}\n\nexport const handleError = error => {\n\terror.message = `[Cube] ${error.message}`\n\tthrow error;\n};\n","import {handleError} from './errors.js'\nimport console from './console.js'\n\nconst isSimple = (value) => {\n\tlet type = typeof value;\n\treturn type !== 'object' && type !== 'function' && type !== 'undefined' || value === null\n};\n\nexport default class Fact {\n\t/**\n\t * @throw {NotFoundFactId}\n\t * */\n\tconstructor(data) {\n\t\ttry {\n\t\t\tfor (let key in data) {\n\t\t\t\tif (!data.hasOwnProperty(key)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (isSimple(data[key])) {\n\t\t\t\t\tthis[key] = data[key];\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn(`[Fact] value of prop \"${key}\" has an unspecified value: ${data[key]}`)\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\thandleError(error);\n\t\t}\n\t}\n}\n","import Fact from './Fact.js'\n\n/**\n * Cell. A piece of data obtained by defining one element\n * in each dimension of a multidimensional array.\n * The cells of the hypercube can be empty or full.\n *\n * These are aggregated data\n *\n * summary - to describe the values of data in cells\n *\n * each cell is an intersection of all the dimensions of the cube\n * */\nexport default class Cell extends Fact {\n\n}\n","import Cell from './Cell.js'\n\nfunction uuidv4() {\n\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n\t\tlet r = Math.random() * 16 | 0;\n\t\tlet v = c == 'x' ? r : (r & 0x3 | 0x8);\n\t\treturn v.toString(16);\n\t});\n}\n\n/**\n * Empty cells - in the fact table there is no data for them\n * The cell is identified by a tuple\n * */\nexport default class EmptyCell extends Cell {\n\tconstructor(data, options) {\n\t\tif (!data.id) {\n\t\t\tdata.id = EmptyCell.generateId()\n\t\t}\n\t\tsuper(data, options)\n\t}\n\t/**\n\t * @return {EmptyCell}\n\t * */\n\tstatic createEmptyCell(options) {\n\t\treturn new EmptyCell(options)\n\t}\n\t/**\n\t * @param {Cell|{ id: string|number }} cell\n\t * @return {boolean}\n\t * */\n\tstatic isEmptyCell(cell) {\n\t\treturn typeof cell.id === 'string'\n\t}\n\t/**\n\t * @return {string}\n\t * */\n\tstatic generateId() {\n\t\treturn uuidv4()\n\t}\n}\n","/**\n * Element of dimension. Serving to determine the position and description of the data element\n * */\nexport default class Member {\n\tconstructor(data) {\n\t\tObject.assign(this, data);\n\t}\n}\n","import Member from './Member.js'\n\n/**\n * Introductory elements. Input elements have values that are manually loaded\n * that is, they are not the result of calculating data\n * */\nexport default class InputMember extends Member {}\n","import Member from './Member.js'\nimport InputMember from \"./InputMember.js\";\n\n/**\n * The main task is to parse the data array into tables\n *\n * is a special case of snowflake dimensionHierarchies\n * where every dimension is represented by one table even if the dimensions has multiple levels\n *\n * snowflaking - normalization process of measurement tables\n * */\nexport default class SnowflakeBuilder {\n\tstatic anotherBuild(factTable, cells, dimensionsTrees, cellTable, factPrimaryKey) {\n\n\t\t// for each dimension\n\t\tdimensionsTrees.forEach(dimensionTree => {\n\t\t\tSnowflakeBuilder.anotherBuildOne(dimensionTree, cells, cellTable, factTable, factPrimaryKey);\n\t\t});\n\t}\n\n\tstatic anotherBuildOne(dimensionTree, cells, cellTable, factTable, factPrimaryKey) {\n\t\t// for each hierarchy and level of dimension\n\t\tdimensionTree.tracePostOrder((dimensionTable, dimensionTree) => {\n\t\t\tSnowflakeBuilder.processDimension(dimensionTree, cells, cellTable, factTable, factPrimaryKey)\n\t\t});\n\t}\n\n\tstatic processDimension(dimensionTree, cells, cellTable, factTable, factPrimaryKey) {\n\t\tconst dimensionTable = dimensionTree.getTreeValue();\n\t\tconst { dimension, keyProps = [], otherProps = [], members: memberList, foreignKey, primaryKey } = dimensionTable;\n\t\tconst childIdAttributes = dimensionTree.getChildTrees().map(dimensionTree => dimensionTree.getTreeValue().foreignKey);\n\t\tconst childDimensions = dimensionTree.getChildTrees().map(dimensionTree => dimensionTree.getTreeValue().dimension);\n\n\t\tlet totalMemberList = [];\n\n\t\tconst existMemberCount = memberList.length;\n\t\tconst args = [factPrimaryKey, primaryKey, foreignKey, existMemberCount, factTable, cells, dimension, keyProps, otherProps, cells, cellTable];\n\n\t\tif (!childIdAttributes.length) {\n\t\t\tconst keyIdMap = SnowflakeBuilder.createKeyIdMap.apply(null, args);\n\t\t\ttotalMemberList = SnowflakeBuilder.createMembersDataByKeyIdMap(keyIdMap, cells, keyProps, otherProps, primaryKey, foreignKey);\n\t\t} else {\n\t\t\tlet entitiesParts = [];\n\n\t\t\tchildIdAttributes.forEach((childIdAttribute, index) => {\n\n\t\t\t\tconst firstChildDimension = childDimensions[index];\n\t\t\t\tconst dimensionTable = dimensionTree.getDimensionTreeByDimension(firstChildDimension).getTreeValue(); //here\n\t\t\t\tconst memberListForFilter = dimensionTable.members;\n\n\t\t\t\tentitiesParts = SnowflakeBuilder.mapFilter(childIdAttribute, cells, memberListForFilter, dimensionTable); //here\n\n\t\t\t\tlet countId = 0;\n\n\t\t\t\tentitiesParts.forEach(entitiesPart => {\n\t\t\t\t\tif (entitiesPart.length) {\n\n\t\t\t\t\t\tlet membersData;\n\n\t\t\t\t\t\t// order only for first child of level\n\t\t\t\t\t\tif (index === 0){\n\t\t\t\t\t\t\tconst entitiesArgs = [...args];\n\t\t\t\t\t\t\tentitiesArgs[5] = entitiesPart;\n\t\t\t\t\t\t\tentitiesArgs.push(countId);\n\t\t\t\t\t\t\tconst keyIdMap = SnowflakeBuilder.createKeyIdMap.apply(null, entitiesArgs);\n\t\t\t\t\t\t\tmembersData = SnowflakeBuilder.createMembersDataByKeyIdMap(keyIdMap, entitiesPart, keyProps, otherProps, primaryKey, foreignKey);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// then just search target member\n\t\t\t\t\t\t\tmembersData = entitiesPart.map(part => totalMemberList.find(data => part[foreignKey] === data[primaryKey]))\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcountId = countId + membersData.length;\n\n\t\t\t\t\t\tconst etalon = entitiesPart[0];\n\n\t\t\t\t\t\t// write data\n\t\t\t\t\t\tmembersData.forEach(member => {\n\t\t\t\t\t\t\tmember[childIdAttribute] = etalon[childIdAttribute];\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// clear source\n\t\t\t\t\t\tentitiesPart.forEach(entityPart => {\n\t\t\t\t\t\t\tdelete entityPart[childIdAttribute];\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (!totalMemberList.length){\n\t\t\t\t\t\t\tconst totalMemberListCount = totalMemberList.length;\n\t\t\t\t\t\t\tconst startFrom = existMemberCount + totalMemberListCount;\n\n\t\t\t\t\t\t\tmembersData.forEach((member, index) => {\n\t\t\t\t\t\t\t\tmember[primaryKey] = (startFrom + index + 1);\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\ttotalMemberList = membersData\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmembersData.forEach(data => {\n\t\t\t\t\t\t\t\tconst find = totalMemberList.find(memberData => memberData[primaryKey] === data[primaryKey]);\n\t\t\t\t\t\t\t\tif (find){\n\t\t\t\t\t\t\t\t\t// Object.assign(find, data)\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttotalMemberList.push(data);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t})\n\t\t}\n\n\t\tfunction deleteProps(fact, props, factPrimaryKey) {\n\t\t\tprops.forEach(prop => {\n\t\t\t\tif (prop !== factPrimaryKey) {\n\t\t\t\t\tdelete fact[prop];\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// только после того как список сформирован, удалаять данные из ячеек\n\t\tcells.forEach(cell => {\n\t\t\tdeleteProps(cell, keyProps, factPrimaryKey);\n\t\t\tdeleteProps(cell, otherProps, factPrimaryKey);\n\t\t});\n\n\t\ttotalMemberList.map(data => new Member(data)).forEach(member => {\n\t\t\tdimensionTable.addMember(member)\n\t\t});\n\t}\n\n\t/**\n\t * Method filter cells by members of a dimension\n\t * @param {string} foreignKey\n\t * @param {Cell[]} cells\n\t * @param {Member[]} memberList\n\t * @param {DimensionTable} dimensionTable\n\t * @private\n\t * @return {Cell[]}\n\t * */\n\tstatic mapFilter(foreignKey, cells, memberList, dimensionTable) {\n\t\tconst cellTables = [];\n\t\t//todo оптимизировать поиск через хеш\n\t\tmemberList.forEach(member => {\n\t\t\tconst cellTableFiltered = cells.filter(cell => {\n\t\t\t\treturn cell[foreignKey] == dimensionTable.getMemberPrimaryKey(member);\n\t\t\t});\n\t\t\tcellTables.push(cellTableFiltered);\n\t\t});\n\t\treturn cellTables;\n\t}\n\n\t/**\n\t * The method of analyzing the data array and generating new dimension values\n\t *\n\t * @param {object[]} entitiesPart - Data array to the analysis of values for dimension\n\t * @param {number} startFrom\n\t * @param {string} dimension - The dimension for which members will be created\n\t * @param {string[]} keyProps - Names of properties whose values will be used to generate a key that will determine the uniqueness of the new member for dimension\n\t * @param {string[]} otherProps - Names of properties whose values will be appended to the dimension member along with the key properties\n\t * @param {Cell} cells\n\t * @param {Cell[]} cellTable\n\t * @return {[]}\n\t * @private\n\t * */\n\tstatic createKeyIdMap(\n\t\tfactPrimaryKey,\n\t\tprimaryKey,\n\t\tforeignKey,\n\t\texistMemberCount,\n\t\tfactTable,\n\t\tentitiesPart,\n\t\tdimension,\n\t\tkeyProps = [],\n\t\totherProps = [],\n\t\tcells,\n\t\tcellTable,\n\t\t// It is recommended that the key field be a simple integer because a key value is meaningless\n\t\tstartFrom = 0\n\t) {\n\t\t// соотношение созданных id к ключам\n\t\tconst keyIdMap = {};\n\t\tconst restoredCache = {};\n\n\t\t// need restore cache\n\t\tconst existedCells = cellTable.filter(cell => {\n\t\t\treturn cells.indexOf(cell) === -1\n\t\t});\n\t\texistedCells.forEach(cell => {\n\t\t\t// собрать ключ на основе ключевых значений\n\t\t\tconst fact = factTable.find(fact => fact[factPrimaryKey] === cell[factPrimaryKey]);\n\t\t\tconst surrogateKey = SnowflakeBuilder.createKeyFromProps(keyProps, fact);\n\t\t\t// если ключ уникальный создается подсущность и назначается ей присваивается уникальный id (уникальность достигается простым счетчиком)\n\t\t\tif (!(surrogateKey in restoredCache)) {\n\t\t\t\trestoredCache[surrogateKey] = ++startFrom;\n\t\t\t}\n\t\t});\n\n\t\t// создания групп по уникальным ключам\n\t\tentitiesPart.forEach(entityPart => {\n\n\t\t\t// собрать ключ на основе ключевых значений\n\t\t\tconst surrogateKey = SnowflakeBuilder.createKeyFromProps(keyProps, entityPart);\n\n\t\t\t// если ключ уникальный создается подсущность и назначается ей присваивается уникальный id (уникальность достигается простым счетчиком)\n\t\t\tif (!(surrogateKey in keyIdMap) && !(surrogateKey in restoredCache)) {\n\t\t\t\tkeyIdMap[surrogateKey] = ++startFrom;\n\t\t\t}\n\n\t\t\t// оставить в нормальной форме ссылку на id под сущности\n\t\t\tconst id = keyIdMap[surrogateKey];\n\t\t\tentityPart[foreignKey] = id;\n\t\t});\n\t\t\n\t\treturn keyIdMap;\n\t}\n\n\tstatic createMembersDataByKeyIdMap(keyIdMap, entitiesPart, keyProps, otherProps, primaryKey, foreignKey) {\n\t\tconst members = [];\n\n\t\tObject.keys(keyIdMap).forEach(key => {\n\t\t\tconst id = keyIdMap[key];\n\t\t\tconst entityPart = entitiesPart.find(entityPart => entityPart[foreignKey] === id);\n\t\t\tconst memberData = SnowflakeBuilder.createMemberData(id, [].concat(keyProps).concat(otherProps), entityPart, primaryKey);\n\n\t\t\tmembers.push(memberData);\n\t\t});\n\n\t\treturn members;\n\t}\n\n\tstatic createMemberData(id, props, data, primaryKey) {\n\t\tconst memberData = {};\n\t\tmemberData[primaryKey] = id;\n\t\tprops.forEach(prop => {\n\t\t\t// исключить идентификатор самой сущности\n\t\t\tif (prop !== primaryKey) {\n\t\t\t\tmemberData[prop] = data[prop]\n\t\t\t}\n\t\t});\n\t\treturn memberData\n\t}\n\n\tstatic createInputMember(id, memberData, data, primaryKey) {\n\t\tconst defaultValue = null;\n\t\tconst defaultData = {};\n\n\t\tmemberData.forEach(propName => {\n\t\t\tdefaultData[propName] = data.hasOwnProperty(propName) ? data[propName] : defaultValue\n\t\t});\n\n\t\tconst createdMemberData = SnowflakeBuilder.createMemberData(id, memberData, defaultData, primaryKey, InputMember);\n\t\treturn new InputMember(createdMemberData)\n\t}\n\n\tstatic createKeyFromProps(props, obj) {\n\t\tconst DIVIDER = ',';\n\n\t\treturn props.map(prop => {\n\t\t\treturn obj[prop]\n\t\t}).join(DIVIDER);\n\t}\n\n\tstatic destroy(cellTable, removedCells, dimensionHierarchies, cube) {\n\t\t// first remove cells\n\t\tremovedCells.forEach(removedCell => {\n\t\t\tconst index = cellTable.indexOf(removedCell);\n\t\t\tif (index !== -1) {\n\t\t\t\tcellTable.splice(index, 1);\n\t\t\t}\n\t\t});\n\t\t// then remove members\n\t\tremovedCells.forEach(fact => {\n\t\t\tdimensionHierarchies.forEach(dimensionTree => {\n\t\t\t\tSnowflakeBuilder.travers([fact], dimensionTree, [SnowflakeBuilder.removeMembers.bind(this, cube, dimensionTree), SnowflakeBuilder.restoreCell]);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Method allows to generate fact tables from cells\n\t * */\n\tstatic denormalize(cellTable, dimensionTrees) {\n\t\tconst facts = [];\n\t\tcellTable.forEach(cell => {\n\t\t\tfacts.push({...cell})\n\t\t});\n\t\tfacts.forEach(fact => {\n\t\t\tdimensionTrees.forEach(dimensionTree => {\n\t\t\t\tSnowflakeBuilder.travers([fact], dimensionTree, [SnowflakeBuilder.restoreCell]);\n\t\t\t});\n\t\t});\n\n\t\treturn facts;\n\t}\n\tstatic restoreCell(member, memberList, dimension, cell, foreignKey, dimensionTable) {\n\t\tconst memberCopy = new Member(member);\n\t\tdimensionTable.deleteMemberId(memberCopy);\n\t\tdelete cell[foreignKey];\n\t\tObject.assign(cell, memberCopy)\n\t}\n\tstatic removeMembers(cube, dimensionTree, member, memberList, dimension, cell, foreignKey) {\n\t\tconst dicedCube = cube.dice({ [dimension]: member });\n\t\tconst dimensionTable = dimensionTree.getDimensionTreeByDimension(dimension).getTreeValue();\n\t\t// last cell was removed at the beginning of the algorithm,\n\t\t// so if the member is no longer used, the projection will be empty\n\t\tif (!dicedCube.getCells().length) {\n\t\t\tdimensionTable.removeMember(member)\n\t\t}\n\t}\n\n\tstatic travers(cellTable, dimensionTree, handlers = () => {}) {\n\t\tconst handleDimensionTree = (dimensionTable, cell) => {\n\t\t\tconst { dimension, members: memberList, foreignKey } = dimensionTable;\n\t\t\tconst idValue = cell[foreignKey];\n\t\t\tconst member = memberList.find(member => {\n\t\t\t\treturn dimensionTable.getMemberPrimaryKey(member) === idValue;\n\t\t\t});\n\t\t\thandlers.forEach(handler => {\n\t\t\t\thandler(member, memberList, dimension, cell, foreignKey, dimensionTable);\n\t\t\t})\n\t\t};\n\t\tcellTable.forEach(cell => {\n\t\t\tdimensionTree.tracePreOrder((tracedDimensionTable, tracedDimensionTree) => {\n\t\t\t\thandleDimensionTree(tracedDimensionTable, cell)\n\t\t\t})\n\t\t});\n\t}\n\n\t/**\n\t * Method allows to delete dimensionTree from cube,\n\t * the cells will be restored, and the members of the measurement are also deleted\n\t * */\n\tstatic destroyDimensionTree(cellTable, removedCells, dimensionTree, cube) {\n\t\tSnowflakeBuilder.travers(cellTable, dimensionTree, [SnowflakeBuilder.removeMembers.bind(this, cube, dimensionTree), SnowflakeBuilder.restoreCell]);\n\t}\n\n}\n","import Member from './Member.js'\nimport {DEFAULT_MEMBER_ID_PROP, DEFAULT_TEMPLATE_FOREIGN_KEY} from './const.js'\nimport SnowflakeBuilder from \"./SnowflakeBuilder.js\";\n\n/**\n * Dimension is a dimension of a cube. A dimension is a primary organizer of measure and attribute information in a cube\n * A dimension will contain some members organized in some hierarchy or hierarchies containing levels.\n * */\nexport default class DimensionTable {\n\tconstructor({ dimension, foreignKey = DimensionTable.genericId(dimension), primaryKey = DEFAULT_MEMBER_ID_PROP, keyProps, otherProps = [], members = [], defaultMemberOptions = {}}) {\n\t\tif (!dimension || !keyProps) {\n\t\t\tthrow Error('Bad definition DimensionTable, params \\\"dimension\\\" and \\\"keyProps\\\" is required');\n\t\t}\n\t\tif (Object.keys(defaultMemberOptions).indexOf(primaryKey) !== -1) {\n\t\t\tthrow Error('Bad definition DimensionTable, \\\"defaultMemberOptions\\\" must not contain a \\\"primaryKey\\\" property');\n\t\t}\n\t\t/** Name of the dimension */\n\t\tthis.dimension = dimension;\n\t\t/** id name */\n\t\tthis.foreignKey = foreignKey;\n\t\t/** id name */\n\t\tthis.primaryKey = primaryKey;\n\t\t/** List of key names properties of the table belonging to the current dimension */\n\t\tthis.keyProps = [].concat(keyProps);\n\t\t/** List of additional names properties of the table belonging to the current dimension */\n\t\tthis.otherProps = [].concat(otherProps);\n\t\t/** member list */\n\t\tthis.members = members.map(memberData => {\n\t\t\treturn new Member(memberData, this.primaryKey)\n\t\t});\n\t\t/** member default property options */\n\t\tthis.defaultMemberOptions = {...defaultMemberOptions};\n\t}\n\t/**\n\t *\n\t * */\n\tsetMemberList(members) {\n\t\t[].splice.apply(this.members, [0, this.members.length].concat(members))\n\t}\n\t/**\n\t *\n\t * */\n\tclearMemberList() {\n\t\tthis.members = [];\n\t}\n\tgetMemberPrimaryKey(member) {\n\t\treturn member[this.primaryKey]\n\t}\n\tgetMemberForeignKey(member) {\n\t\treturn member[this.foreignKey]\n\t}\n\t/**\n\t * @param {Member} member\n\t * */\n\taddMember(member) {\n\t\tif (this.members.indexOf(member) === -1) {\n\t\t\tthis.members.push(member)\n\t\t} else {\n\t\t\tconsole.log('boo')\n\t\t}\n\t}\n\t/**\n\t * @public\n\t * @param {object} memberOptions\n\t * @param {[]} linkProps\n\t * */\n\tcreateMember(memberOptions = {}, linkProps) {\n\t\t// todo тут нужна проверка на то, что все данные для члена измерения присутствуют\n\t\tconst memberData = {...this.defaultMemberOptions, ...memberOptions};\n\t\tconst { keyProps, otherProps, members, primaryKey } = this;\n\t\tconst keys = keyProps.concat(linkProps).concat(otherProps);\n\t\tconst id = DimensionTable.reduceId(members, primaryKey);\n\t\tconst member = SnowflakeBuilder.createInputMember(id, keys, memberData, primaryKey);// todo убрать отсюда\n\t\tthis.addMember(member);\n\t\treturn member;\n\t}\n\t/**\n\t * @public\n\t * Method of generating a unique identifier within the selected space\n\t * */\n\tstatic reduceId(members, primaryKey) {\n\t\tif (members.length) {\n\t\t\treturn members.reduce((acc, curValue) => {\n\t\t\t\treturn acc[primaryKey] > curValue[primaryKey] ? acc : curValue;\n\t\t\t}, 0)[primaryKey] + 1\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n\t/**\n\t * @public\n\t * A way to create a name for a property in which a unique identifier will be stored\n\t * */\n\tstatic genericId(dimension) {\n\t\treturn DEFAULT_TEMPLATE_FOREIGN_KEY.replace('%s', dimension);\n\t}\n\tsetMemberId(member, id) {\n\t\tmember[this.primaryKey] = id;\n\t}\n\tdeleteMemberId(member) {\n\t\tdelete member[this.primaryKey]\n\t}\n\t/**\n\t *\n\t * */\n\tremoveMember(member) {\n\t\tconst index = this.members.indexOf(member);\n\t\tif (index === -1) {\n\t\t\tthrow new Error('represented member was not found', member);\n\t\t}\n\t\tthis.members.splice(index, 1);\n\t}\n\tstatic createDimensionTable(dimensionTable) {\n\t\treturn new DimensionTable(dimensionTable)\n\t}\n}\n","export const DEFAULT_TEMPLATE_FOREIGN_KEY = '%s_id';\nexport const DEFAULT_FACT_ID_PROP = 'id';\nexport const DEFAULT_MEMBER_ID_PROP = 'id';\n","/**\n * Tree traversing https://en.wikipedia.org/wiki/Tree_traversal\n * @class Tree\n * @abstract class cannot be instantiated with new\n * */\nexport default class Tree {\n\t/**\n\t * @public\n\t * @abstract\n\t * @return {Object}\n\t * */\n\tgetTreeValue() {\n\t\tthrow 'abstract method'\n\t}\n\t/**\n\t * @public\n\t * @abstract\n\t * @return {Tree|null}\n\t * */\n\tgetParentTree() {\n\t\tthrow 'abstract method'\n\t}\n\t/**\n\t * @public\n\t * @abstract\n\t * @return {Tree[]}\n\t * */\n\tgetChildTrees() {\n\t\tthrow 'abstract method'\n\t}\n\t/**\n\t * @public\n\t * @return {boolean}\n\t * */\n\tisExternal() {\n\t\treturn !this.getChildTrees().length;\n\t}\n\t/**\n\t * @public\n\t * @return {boolean}\n\t * */\n\tisRoot() {\n\t\treturn this.getParentTree() === null;\n\t}\n\t/**\n\t * @public\n\t * Get root for that tree\n\t * @return {Tree}\n\t * */\n\tgetRoot() {\n\t\tlet root = this;\n\t\tthis.traceUpOrder((tracedTreeValue, tracedTree) => {\n\t\t\tif (tracedTree.isRoot()) {\n\t\t\t\troot = tracedTree;\n\t\t\t}\n\t\t});\n\t\treturn root;\n\t}\n\t/**\n\t * @public\n\t * A walk to root from current Tree, the current Tree and root entered to the chain\n\t * @param {function} callback\n\t * */\n\ttraceUpOrder(callback) {\n\t\tconst tree = this;\n\t\tconst parentTree = tree.getParentTree();\n\t\tconst treeValue = tree.getTreeValue();\n\t\tcallback(treeValue, tree);\n\t\tif (parentTree !== null) {\n\t\t\tparentTree.traceUpOrder(callback);\n\t\t}\n\t}\n\t/**\n\t * @public\n\t * A walk in which the children are traversed before their respective parents are traversed\n\t * @param {function} callback\n\t * */\n\ttracePostOrder(callback) {\n\t\tconst tree = this;\n\t\tconst childTrees = tree.getChildTrees();\n\t\tconst treeValue = tree.getTreeValue();\n\t\tif (childTrees.length) {\n\t\t\tchildTrees.forEach(childTree => {\n\t\t\t\tchildTree.tracePostOrder(callback);\n\t\t\t});\n\t\t}\n\t\tcallback(treeValue, tree);\n\t}\n\t/**\n\t * @public\n\t *  A walk in which each parent tree is traversed before its children is called a pre-order walk\n\t * */\n\ttracePreOrder(callback) {\n\t\tconst tree = this;\n\t\tconst childTrees = tree.getChildTrees();\n\t\tconst treeValue = tree.getTreeValue();\n\t\tcallback(treeValue, tree);\n\t\tif (childTrees.length) {\n\t\t\tchildTrees.forEach(childTree => {\n\t\t\t\tchildTree.tracePreOrder(callback);\n\t\t\t});\n\t\t}\n\t}\n}\n","import DimensionTable from './DimensionTable.js'\nimport Tree from './Tree.js'\nimport {DimensionException} from './errors.js'\n/**\n * It defines the relationship of generalization and specialization (roll-up/drill-down)\n * @throws {DimensionException}\n * */\nexport default class DimensionTree extends Tree {\n\tconstructor(dimensionTree) {\n\t\tsuper();\n\n\t\tconst {dimensionTable, level = [], parentNode = null} = dimensionTree;\n\t\t\n\t\tObject.defineProperties(this, {\n\t\t\tdimensionTable: {\n\t\t\t\t/**\n\t\t\t\t * @property\n\t\t\t\t * @name DimensionTree#dimensionTable\n\t\t\t\t * */\n\t\t\t\tvalue: DimensionTable.createDimensionTable(dimensionTable),\n\t\t\t\teditable: false,\n\t\t\t\tenumerable: true\n\t\t\t},\n\t\t\tparentNode: {\n\t\t\t\t/**\n\t\t\t\t * @property {DimensionTree|null}\n\t\t\t\t * @name DimensionTree#parentNode\n\t\t\t\t * */\n\t\t\t\tvalue: parentNode,\n\t\t\t\tenumerable: false,\n\t\t\t\teditable: false\n\t\t\t},\n\t\t\tlevel: {\n\t\t\t\t/**\n\t\t\t\t * @property {DimensionTree[]}\n\t\t\t\t * @name DimensionTree#level\n\t\t\t\t * */\n\t\t\t\tvalue: level.map(dimensionTreeData => {\n\t\t\t\t\treturn new DimensionTree({ ...dimensionTreeData, parentNode: this })\n\t\t\t\t}),\n\t\t\t\tenumerable: true,\n\t\t\t\teditable: false\n\t\t\t}\n\t\t});\n\t\tthis.validateDimensions();\n\t}\n\tvalidateDimensions(){\n\t\tconst dimensions = [];\n\t\tthis.tracePostOrder(tracedDimensionTreeValue => {\n\t\t\tconst {dimension} = tracedDimensionTreeValue;\n\t\t\tif (dimensions.indexOf(dimension) === -1){\n\t\t\t\tdimensions.push(dimension)\n\t\t\t} else {\n\t\t\t\tthrow new DimensionException();\n\t\t\t}\n\t\t})\n\t}\n\tstatic createDimensionTree(dimensionTreeData) {\n\t\t// todo add validation\n\t\treturn new DimensionTree(dimensionTreeData);\n\t}\n\tstatic createProxyDimensionTree(dimensionTree){\n\t\tconst newDimensionTree = dimensionTree.cloneDimensionTreeWithoutMembers();\n\t\tdimensionTree.tracePostOrder(tracedTreeValue => {\n\t\t\tconst { dimension: tracedDimension, members } = tracedTreeValue;\n\t\t\t\n\t\t\tnewDimensionTree\n\t\t\t\t.getDimensionTreeByDimension(tracedDimension)\n\t\t\t\t.getTreeValue()\n\t\t\t\t.setMemberList(members);\n\t\t});\n\t\treturn newDimensionTree;\n\t}\n\t/**\n\t * @public\n\t * @return {DimensionTable}\n\t * */\n\tgetTreeValue() {\n\t\treturn this.dimensionTable;\n\t}\n\t/**\n\t * @public\n\t * @return {DimensionTree|null}\n\t * */\n\tgetParentTree() {\n\t\treturn this.parentNode;\n\t}\n\t/**\n\t * @public\n\t * @return {DimensionTree[]}\n\t * */\n\tgetChildTrees() {\n\t\treturn this.level;\n\t}\n\t/**\n\t * @public\n\t * @param {string} dimension\n\t * @return {DimensionTree|undefined}\n\t * */\n\tgetDimensionTreeByDimension(dimension) {\n\t\tconst root = this.getRoot();\n\t\tlet search = void 0;\n\t\troot.tracePostOrder((dimensionTreeValue, dimensionTree) => {\n\t\t\tif (dimensionTreeValue.dimension === dimension){\n\t\t\t\tsearch = dimensionTree;\n\t\t\t}\n\t\t});\n\t\treturn search;\n\t}\n\t/**\n\t * @public\n\t * @param {Member} member\n\t * @return {DimensionTree|undefined}\n\t * */\n\tcreateProjectionOntoMember(member) {\n\t\t// 1 create copy of hierarchy with empty members\n\t\tconst newDimensionTreeByMember = this.cloneDimensionTreeWithoutMembers();\n\n\t\tthis.projectDrillDown(newDimensionTreeByMember, member);\n\t\tthis.projectDrillUp(newDimensionTreeByMember, member);\n\n\t\treturn newDimensionTreeByMember;\n\t}\n\tprojectDrillDown(dimensionTree, member){\n\t\tthis.projectDrill(dimensionTree, member, \"traceUpOrder\", \"drillDownDimensionMembers\")\n\t}\n\tprojectDrillUp(dimensionTree, member){\n\t\tthis.projectDrill(dimensionTree, member, \"tracePreOrder\", \"drillUpDimensionMembers\")\n\t}\n\tprojectDrill(dimensionTree, member, traceMethodName, method){\n\t\tlet lastTracedMembers;\n\t\tlet lastTracedDimensionTree;\n\t\tthis[traceMethodName]((tracedDimensionTreeValue, tracedDimensionTree) => {\n\t\t\tconst { dimension: tracedDimension } = tracedDimensionTreeValue;\n\n\t\t\tconst drillMembers = tracedDimensionTree == this\n\t\t\t\t? [member]\n\t\t\t\t: lastTracedDimensionTree[method](lastTracedMembers);\n\n\t\t\tdimensionTree\n\t\t\t\t.getDimensionTreeByDimension(tracedDimension)\n\t\t\t\t.getTreeValue()\n\t\t\t\t.setMemberList(drillMembers);\n\n\t\t\tlastTracedMembers = drillMembers;\n\t\t\tlastTracedDimensionTree = tracedDimensionTree;\n\t\t});\n\t}\n\tcloneDimensionTreeWithoutMembers(){\n\t\t// todo new members must be not created here\n\t\tconst clone = new DimensionTree(this.getRoot());\n\t\tclone.tracePostOrder(dimensionTreeValue => {\n\t\t\tdimensionTreeValue.clearMemberList();\n\t\t});\n\t\treturn clone;\n\t}\n\t/**\n\t * @public\n\t * @param {Member} member\n\t * */\n\tremoveProjectionOntoMember(member) {\n\t\t// 1 get projection\n\t\tconst projectionDimensionTree = this.cloneDimensionTreeWithoutMembers();\n\t\tthis.projectDrillDown(projectionDimensionTree, member);\n\n\t\t// 2 subtract projection\n\t\tthis.subtractDimensionTree(projectionDimensionTree);\n\t\t// 3 return first level members of projection\n\t\tconst endToBeRemovedMember = {};\n\n\t\tconst {\n\t\t\tdimension: dimensionProjection,\n\t\t\tmembers: membersProjection\n\t\t} = projectionDimensionTree.getRoot().getTreeValue();\n\n\t\tendToBeRemovedMember[dimensionProjection] = membersProjection;\n\n\t\treturn endToBeRemovedMember;\n\t}\n\t/**\n\t * @private\n\t * @param {DimensionTree} dimensionTree\n\t * */\n\tsubtractDimensionTree(dimensionTree) {\n\t\t// remove intersection\n\t\tconst toBeRemovedSpace = {};\n\n\t\tdimensionTree.tracePostOrder(dimensionTreeValue => {\n\t\t\tconst {dimension, members} = dimensionTreeValue;\n\t\t\ttoBeRemovedSpace[dimension] = members;\n\t\t});\n\n\t\tconst memberList = this.getTreeValue().members;\n\n\t\t// travers down\n\t\tif (memberList.length === 1) {\n\t\t\tthis.tracePreOrder((tracedDimensionTable, tracedDimensionTree) => {\n\t\t\t\tconst {members: childMembers, dimension: childDimension} = tracedDimensionTable;\n\t\t\t\ttoBeRemovedSpace[childDimension] = childMembers;\n\t\t\t})\n\t\t}\n\n\t\t// remove removal space\n\t\tObject.keys(toBeRemovedSpace).forEach(dimension => {\n\t\t\tconst currentDimensionTree = this.getDimensionTreeByDimension(dimension);\n\t\t\tconst dimensionTable = currentDimensionTree.getTreeValue();\n\t\t\ttoBeRemovedSpace[dimension].forEach(member => {\n\t\t\t\tdimensionTable.removeMember(member);\n\t\t\t})\n\t\t});\n\t}\n\tunionDimensionTree(dimensionTree){\n\t\tconst toBeAddedSpace = {};\n\t\tdimensionTree.tracePostOrder(dimensionTreeValue => {\n\t\t\tconst {dimension, members} = dimensionTreeValue;\n\t\t\ttoBeAddedSpace[dimension] = members;\n\t\t});\n\n\t\tObject.keys(toBeAddedSpace).forEach(dimension => {\n\t\t\tconst currentDimensionTree = this.getDimensionTreeByDimension(dimension);\n\t\t\tconst dimensionTable = currentDimensionTree.getTreeValue();\n\t\t\ttoBeAddedSpace[dimension].forEach(member => {\n\t\t\t\tdimensionTable.addMember(member);\n\t\t\t})\n\t\t});\n\t}\n\t/**\n\t * @public\n\t * @param {Member[]} members\n\t * @return {Member[]}\n\t * */\n\tdrillDownDimensionMembers(members = this.getTreeValue().members) {\n\t\tif (this.isRoot()) {\n\t\t\treturn members;\n\t\t}\n\t\tconst parentTree = this.getParentTree();\n\t\tconst parentDimensionTable = parentTree.getTreeValue();\n\t\tconst dimensionTable = this.getTreeValue();\n\t\tconst { members: parentMembers } = parentDimensionTable;\n\t\tconst drillMembers = [];\n\t\tmembers.forEach(member => {\n\t\t\tparentMembers.forEach(parentMember => {\n\t\t\t\tif (dimensionTable.getMemberForeignKey(parentMember) === parentDimensionTable.getMemberPrimaryKey(member)) {\n\t\t\t\t\tif (drillMembers.indexOf(parentMember) === -1) {\n\t\t\t\t\t\tdrillMembers.push(parentMember)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t});\n\t\treturn drillMembers;\n\t}\n\t/**\n\t * @public\n\t * @this {DimensionTree}\n\t * @param {Member[]} members\n\t * @return {Member[]}\n\t * */\n\tdrillUpDimensionMembers(members = this.getTreeValue().members) {\n\t\tif (this.isExternal()) {\n\t\t\treturn members;\n\t\t}\n\t\tconst childTrees = this.getChildTrees();\n\t\tconst childTree = childTrees[0]; // todo not for one child always\n\t\tconst childDimensionTable = childTree.getTreeValue();\n\t\tconst { members: childMembers } = childDimensionTable;\n\t\tconst drillMembers = [];\n\t\tmembers.forEach(member => {\n\t\t\tchildMembers.forEach(childMember => {\n\t\t\t\tif (childDimensionTable.getMemberForeignKey(member) === childDimensionTable.getMemberPrimaryKey(childMember)) {\n\t\t\t\t\tif (drillMembers.indexOf(childMember) === -1) {\n\t\t\t\t\t\tdrillMembers.push(childMember)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t});\n\t\treturn drillMembers;\n\t}\n\t/**\n\t * @public\n\t * @param {object?} memberOptions\n\t * */\n\tcreateMember(memberOptions = {}) {\n\t\tconst dimensionTable = this.getTreeValue();\n\t\tconst childIdAttributes = this.getChildTrees().map(dimensionTree =>\n\t\t\tdimensionTree.getTreeValue().foreignKey\n\t\t);\n\t\tconst linkProps = [];\n\t\tchildIdAttributes.forEach(foreignKey => {\n\t\t\tlinkProps.push(foreignKey)\n\t\t});\n\t\treturn dimensionTable.createMember(memberOptions, linkProps)\n\t}\n}\n","import DimensionTree from './DimensionTree.js'\n\n/**\n * The elements of a dimension can be organized as a hierarchy\n * Hierarchy is a dimension hierarchy of a cube\n * */\nexport default class DimensionHierarchy {\n\tconstructor({ dimensionTree, activeDimension, hierarchy}) {\n\t\tif (!hierarchy) {\n\t\t\tthrow Error('attribute \"hierarchy\" must be defined')\n\t\t}\n\t\tthis.dimensionTree = dimensionTree instanceof DimensionTree\n\t\t\t? dimensionTree\n\t\t\t: DimensionTree.createDimensionTree(dimensionTree);\n\t\tthis.activeDimension = activeDimension || this.dimensionTree.getTreeValue().dimension;\n\t\tthis.hierarchy = hierarchy;\n\t}\n\tgetDimensionTree() {\n\t\treturn this.dimensionTree;\n\t}\n\thasDimension(dimension) {\n\t\treturn !!this.dimensionTree.getDimensionTreeByDimension(dimension);\n\t}\n\tgetActiveDimension() {\n\t\treturn this.activeDimension;\n\t}\n\tsetActiveDimension(activeDimension) {\n\t\tthis.activeDimension = activeDimension;\n\t}\n\tgetHierarchy() {\n\t\treturn this.hierarchy;\n\t}\n\tstatic createDimensionHierarchy(dimensionHierarchy) {\n\t\treturn new DimensionHierarchy(dimensionHierarchy)\n\t}\n}\n","/**\n * The cell is identified by a tuple\n * tuples can uniquely identify every cell in the cube\n * Tuple is an ordered collection of one or more members from different dimensions\n * */\nexport default class Tuple {\n\tconstructor(options) {\n\t\tObject.assign(this, options)\n\t}\n}\n","export default class Space {\n\t/**\n\t *\n\t * */\n\tstatic union() {\n\t\tconst newSpace = {};\n\t\tconst arg = [...arguments];\n\t\targ.forEach(space => {\n\t\t\tSpace.add(newSpace, space);\n\t\t});\n\t\treturn newSpace;\n\t}\n\t/**\n\t *\n\t * */\n\tstatic add(targetSpace, otherSpace) {\n\t\tObject.keys(otherSpace).forEach(key => {\n\t\t\tif (!targetSpace[key]) {\n\t\t\t\ttargetSpace[key] = [];\n\t\t\t}\n\t\t\tArray.prototype.push.apply(targetSpace[key], otherSpace[key])\n\t\t})\n\t}\n}\n","const toString = Object.prototype.toString\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction getTag(value) {\n\tif (value == null) {\n\t\treturn value === undefined ? '[object Undefined]' : '[object Null]'\n\t}\n\treturn toString.call(value)\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * isObjectLike({})\n * // => true\n *\n * isObjectLike([1, 2, 3])\n * // => true\n *\n * isObjectLike(Function)\n * // => false\n *\n * isObjectLike(null)\n * // => false\n */\nfunction isObjectLike(value) {\n\treturn typeof value == 'object' && value !== null\n}\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1\n * }\n *\n * isPlainObject(new Foo)\n * // => false\n *\n * isPlainObject([1, 2, 3])\n * // => false\n *\n * isPlainObject({ 'x': 0, 'y': 0 })\n * // => true\n *\n * isPlainObject(Object.create(null))\n * // => true\n */\nfunction isPlainObject(value) {\n\tif (!isObjectLike(value) || getTag(value) != '[object Object]') {\n\t\treturn false\n\t}\n\tif (Object.getPrototypeOf(value) === null) {\n\t\treturn true\n\t}\n\tlet proto = value\n\twhile (Object.getPrototypeOf(proto) !== null) {\n\t\tproto = Object.getPrototypeOf(proto)\n\t}\n\treturn Object.getPrototypeOf(value) === proto\n}\n\nexport default isPlainObject","import EmptyCell from './EmptyCell.js'\nimport Member from './Member.js'\nimport DimensionTree from './DimensionTree.js'\nimport DimensionHierarchy from './DimensionHierarchy.js'\nimport DimensionTable from './DimensionTable.js'\nimport {\n\tInsufficientRollupData,\n} from './errors.js';\nimport SnowflakeBuilder from './SnowflakeBuilder.js'\nimport console from './console.js'\nimport Tuple from './Tuple.js'\nimport Space from './Space.js'\nimport Cell from './Cell.js'\nimport { DEFAULT_FACT_ID_PROP } from './const.js'\nimport isPlainObject from \"./isPlainObject.js\"\nimport {NotFoundFactId} from \"./errors.js\";\n\n/**\n * It a means to retrieve data\n *\n * Base class for normalizing a denormalized data array\n * and analyzing query according to a given scheme\n *\n * */\nclass Cube {\n\t/**\n\t * @param {object | Cube} cube\n\t * @throw {TypeError}\n\t * */\n\tconstructor(cube = {}) {\n\t\tif (!(isPlainObject(cube) || cube instanceof Cube)){\n\t\t\tthrow TypeError('The argument must be plain object or instance of Cube')\n\t\t}\n\t\tlet {\n\t\t\tdimensionHierarchies = [],\n\t\t\tcellTable = [],\n\t\t\tdefaultFactOptions = {},\n\t\t\tfactPrimaryKey = DEFAULT_FACT_ID_PROP\n\t\t} = cube;\n\n\t\tthis.defaultFactOptions = defaultFactOptions;\n\t\tthis.factPrimaryKey = factPrimaryKey;\n\n\t\tthis.dimensionHierarchies = dimensionHierarchies.map(dimensionHierarchy => {\n\t\t\t// duck\n\t\t\tif (dimensionHierarchy.hierarchy) {\n\t\t\t\tif (dimensionHierarchy instanceof DimensionHierarchy) {\n\t\t\t\t\treturn dimensionHierarchy;\n\t\t\t\t} else {\n\t\t\t\t\treturn DimensionHierarchy.createDimensionHierarchy(dimensionHierarchy);\n\t\t\t\t}\n\t\t\t} else if (dimensionHierarchy.dimensionTable) {\n\t\t\t\tif ( dimensionHierarchy instanceof DimensionTree ){\n\t\t\t\t\treturn dimensionHierarchy;\n\t\t\t\t} else {\n\t\t\t\t\treturn DimensionTree.createDimensionTree(dimensionHierarchy);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dimensionHierarchy instanceof DimensionTable) {\n\t\t\t\t\treturn dimensionHierarchy;\n\t\t\t\t} else {\n\t\t\t\t\treturn DimensionTable.createDimensionTable(dimensionHierarchy);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tthis.cellTable = cellTable.map(cellData => {\n\t\t\tif (cellData instanceof Cell) {\n\t\t\t\treturn cellData\n\t\t\t} else {\n\t\t\t\treturn EmptyCell.isEmptyCell(cellData) ? new EmptyCell(cellData) : new Cell(cellData)\n\t\t\t}\n\t\t});\n\n\t\t// const residuals = residuals(this);\n\t\t// const count = residuals.length;\n\t\t// if (count > 0) {\n\t\t// \tconsole.warn('Fact table has residuals', residuals)\n\t\t// }\n\t}\n\t/**\n\t * is the act of picking a rectangular subset of a cube by choosing a single value\n\t * for one of its dimensions, creating a new cube with one fewer dimension.\n\t * @public\n\t * @param {string} dimension\n\t * @param {Member} member\n\t * @return {Cube}\n\t * */\n\tslice(dimension, member) {\n\t\treturn this.dice({ [dimension]: member })\n\t}\n\t/**\n\t * @public\n\t * @param {object} set\n\t * @return {Cube}\n\t * @throw {TypeError}\n\t * @throw {RangeError}\n\t * */\n\tdice(set) {\n\t\tif (!(isPlainObject(set) || set instanceof Tuple)){\n\t\t\tthrow TypeError(\"The argument must be a plain object\")\n\t\t}\n\t\t\n\t\t// always work with arrays as value\n\t\tconst toMultiset = (value) => {\n\t\t\treturn Array.isArray(value) ? value : [value];\n\t\t};\n\t\t\n\t\t// change member data to original member objects\n\t\tconst toOriginal = (membersData, dimension) => {\n\t\t\tconst dimensionTree = getDimensionTreeByDimension.call(this, dimension);\n\t\t\tconst dimensionTable = dimensionTree.getTreeValue();\n\t\t\tconst members = dimensionTable.members;\n\t\t\t//replace memberData with original members\n\t\t\tmembersData.forEach((memberData, index) => {\n\t\t\t\tlet member = members.find(member => dimensionTable.getMemberPrimaryKey(member) === dimensionTable.getMemberPrimaryKey(memberData));\n\t\t\t\tif (!member) {\n\t\t\t\t\tthrow RangeError(`Not found member by id ${dimensionTable.getMemberPrimaryKey(member)}`)\n\t\t\t\t}\n\t\t\t\tif (membersData instanceof Member){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tmembersData[index] = member;\n\t\t\t});\n\t\t\treturn membersData;\n\t\t};\n\t\t\n\t\tconst originalMultiset = {};\n\t\tObject.keys(set).forEach((dimension) => {\n\t\t\tlet value = set[dimension];\n\t\t\tvalue = toMultiset(value);\n\t\t\tvalue = toOriginal(value, dimension);\n\t\t\toriginalMultiset[dimension] = value;\n\t\t});\n\t\t\n\t\tconst dimensions = Object.keys(originalMultiset);\n\t\t\n\t\t// 1 make one projection on to member\n\t\tconst dimensionHierarchiesLength = this.dimensionHierarchies.length;\n\t\tif (dimensions.length > dimensionHierarchiesLength) {\n\t\t\tthrow Error(`Set must have a size not more than ${dimensionHierarchiesLength} dimensions`)\n\t\t}\n\n\t\tconst projectionDimensionHierarchies = [];\n\n\t\t// for every dimension in set\n\t\tconst totalSpaces = dimensions.map(dimension => {\n\n\t\t\tlet dimensionTreeProjection;\n\t\t\tconst members = originalMultiset[dimension];\n\t\t\t// ищется его расширенная версия для каждого члена\n\t\t\tconst spacesForCells = members.map(member => {\n\n\t\t\t\tlet searchedInTree = getDimensionTreeByDimension.call(this, dimension);\n\n\t\t\t\tconst current = searchedInTree.cloneDimensionTreeWithoutMembers();\n\n\t\t\t\tsearchedInTree.projectDrillDown(current, member);\n\t\t\t\tsearchedInTree.projectDrillUp(current, member);\n\n\t\t\t\tif (dimensionTreeProjection){\n\t\t\t\t\tdimensionTreeProjection.unionDimensionTree(current)\n\t\t\t\t} else {\n\t\t\t\t\tdimensionTreeProjection = current;\n\t\t\t\t}\n\t\t\t\tconst {\n\t\t\t\t\tdimension: dimensionProjection,\n\t\t\t\t\tmembers: membersProjection\n\t\t\t\t} = dimensionTreeProjection.getRoot().getTreeValue();\n\n\t\t\t\treturn { [dimensionProjection]: membersProjection };\n\t\t\t});\n\n\t\t\tif (dimensionTreeProjection){\n\t\t\t\tprojectionDimensionHierarchies.push(dimensionTreeProjection);\n\t\t\t}\n\n\t\t\t// после чего эти расширенные версии объекдиняются\n\t\t\tconst totalSpace = Space.union(...spacesForCells);\n\n\t\t\treturn totalSpace;\n\t\t});\n\n\t\t// фильтрация продолжается\n\t\tlet filteredCellTable = this.getCells();\n\n\t\tconst cellBelongsToSpace = (cell, space) => {\n\t\t\tconst somePropOfCellNotBelongToSpace = Object.keys(space).some(dimension => {\n\t\t\t\tconst members = space[dimension];\n\t\t\t\tconst { foreignKey, primaryKey } = getDimensionTreeByDimension.call(this, dimension).getTreeValue();\n\t\t\t\tconst finded = members.find(member => {\n\t\t\t\t\treturn member[primaryKey] === cell[foreignKey]\n\t\t\t\t});\n\t\t\t\treturn !finded;\n\t\t\t});\n\t\t\treturn !somePropOfCellNotBelongToSpace;\n\t\t};\n\n\t\ttotalSpaces.forEach(space => {\n\t\t\t// и ищутся те ячейки, которые принадлежат получившейся области\n\t\t\tfilteredCellTable = filteredCellTable.filter(cell => {\n\t\t\t\treturn cellBelongsToSpace(cell, space)\n\t\t\t});\n\t\t});\n\n\t\t// 2 create new list of dimensionHierarchies\n\t\tconst newDimensionHierarchies = [];\n\t\tthis.dimensionHierarchies.forEach(originalDimensionHierarchy => {\n\t\t\tlet finded = false;\n\t\t\tprojectionDimensionHierarchies.forEach(projectionDimensionHierarchy => {\n\t\t\t\tif (originalDimensionHierarchy.getTreeValue().dimension === projectionDimensionHierarchy.getTreeValue().dimension) {\n\t\t\t\t\tnewDimensionHierarchies.push(projectionDimensionHierarchy);\n\t\t\t\t\tfinded = true;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (!finded) {\n\t\t\t\tconst { members, dimension } = originalDimensionHierarchy.getTreeValue();\n\t\t\t\tconst projectionDimensionHierarchy = DimensionTree.createProxyDimensionTree(originalDimensionHierarchy);\n\t\t\t\tmembers.forEach(member => {\n\t\t\t\t\tlet memberBelongToCells = false;\n\t\t\t\t\tfilteredCellTable.forEach(filteredCell => {\n\t\t\t\t\t\tif (cellBelongsToSpace(filteredCell, { [dimension]: [member] })) {\n\t\t\t\t\t\t\tmemberBelongToCells = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tif (!memberBelongToCells) {\n\t\t\t\t\t\tlet has = projectionDimensionHierarchy.getTreeValue().members.indexOf(member) !== -1;\n\t\t\t\t\t\tif (has) {\n\t\t\t\t\t\t\tprojectionDimensionHierarchy.removeProjectionOntoMember(member)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tnewDimensionHierarchies.push(projectionDimensionHierarchy);\n\t\t\t}\n\t\t});\n\n\t\treturn new SubCube({\n\t\t\tcellTable: filteredCellTable,\n\t\t\tdimensionHierarchies: newDimensionHierarchies,\n\t\t\toriginalCube: this.originalCube || this,\n\t\t\tpreviousCube: this\n\t\t})\n\t}\n\t/**\n\t * The cube introduces generalization relations\n\t * it's operations on dimension hierarchies\n\t * @public\n\t * @param {string} hierarchy\n\t * @param {string} targetDimension\n\t * @return {Cube}\n\t * */\n\tdrillUp(hierarchy, targetDimension) {\n\t\tconst currentHierarchy = getHierarchy.call(this, hierarchy);\n\t\tif (currentHierarchy && currentHierarchy.hasDimension(targetDimension)) {\n\t\t\tcurrentHierarchy.setActiveDimension(targetDimension);\n\t\t}\n\t\treturn this;\n\t}\n\t/**\n\t * The cube introduced specialization relations\n\t * it's operations on dimension hierarchies\n\t * @public\n\t * @param {string} hierarchy\n\t * @param {string} targetDimension\n\t * @return {Cube}\n\t * */\n\tdrillDown(hierarchy, targetDimension) {\n\t\tconst currentHierarchy = getHierarchy.call(this, hierarchy);\n\t\tif (currentHierarchy && currentHierarchy.hasDimension(targetDimension)) {\n\t\t\tcurrentHierarchy.setActiveDimension(targetDimension);\n\t\t}\n\t\treturn this;\n\t}\n\t/**\n\t * @public\n\t * @return {Fact[]} returns facts\n\t * */\n\tgetFacts() {\n\t\treturn denormalize.call(this, this.getCells());\n\t}\n\t/**\n\t * @public\n\t * @param {Object[]} facts\n\t * @throw {TypeError}\n\t * @return {Cube}\n\t * */\n\taddFacts(facts) {\n\t\tif (!Array.isArray(facts)){\n\t\t\tthrow TypeError('The argument must be instance of Array')\n\t\t}\n\t\tfacts.forEach(validateFactData.bind(null, this.factPrimaryKey));\n\t\tconst cells = facts.map(fact => new Cell(fact));\n\t\t[].push.apply(this.getCells(), cells);\n\t\tconst factTable = this.getFacts();\n\t\tSnowflakeBuilder.anotherBuild(factTable, cells, getDimensionTrees.call(this), this.getCells(), this.factPrimaryKey);\n\t\treturn this;\n\t}\n\t/**\n\t * @public\n\t * @param {Object[]} facts\n\t * @throw {TypeError}\n\t * */\n\tremoveFacts(facts) {\n\t\tif (!Array.isArray(facts)){\n\t\t\tthrow TypeError('The argument must be instance of Array')\n\t\t}\n\t\tconst cellTable = this.getCells();\n\t\tconst factPrimaryKey = this.factPrimaryKey;\n\t\tconst removedCells = facts.map(fact => {\n\t\t\treturn cellTable.find(cell => cell[factPrimaryKey] === fact[factPrimaryKey])\n\t\t});\n\t\tthis.removeCells(removedCells);\n\t}\n\t/**\n\t * @public\n\t * @return {Cell[]}\n\t * */\n\tgetCells() {\n\t\treturn this.cellTable;\n\t}\n\t/**\n\t * @public\n\t * @param {Cell[]} cells\n\t * @throw {TypeError}\n\t * */\n\tremoveCells(cells) {\n\t\tif (!Array.isArray(cells)){\n\t\t\tthrow TypeError('The argument must be instance of Array')\n\t\t}\n\t\tcells.forEach((cell) => {\n\t\t\tif (!(cell instanceof Cell)){\n\t\t\t\tthrow TypeError('The list of cells must contain only instances of Cell and EmptyCell')\n\t\t\t}\n\t\t});\n\t\tSnowflakeBuilder.destroy(this.getCells(), cells, this.dimensionHierarchies, this);\n\t}\n\t/**\n\t * @public\n\t * @param {string} dimension - dimension from which the member will be found\n\t * @return {Member[]} returns members\n\t * @throw {TypeError}\n\t * */\n\tgetDimensionMembers(dimension) {\n\t\tif (!(typeof dimension === 'string')){\n\t\t\tthrow TypeError('The first argument must be string')\n\t\t}\n\t\tconst dimensionTree = getDimensionTreeByDimension.call(this, dimension);\n\t\treturn dimensionTree.getTreeValue().members;\n\t}\n\t/**\n\t * @public\n\t * @param {string} dimension - dimension in which the member is created\n\t * @param {object?} customMemberOptions - properties for the created member\n\t * @param {object?} rollupCoordinatesData\n\t * @param {object?} drillDownCoordinatesOptions\n\t * @param {object?} cellData\n\t * @throw {InsufficientRollupData}\n\t * */\n\taddDimensionMember(dimension, customMemberOptions = {}, rollupCoordinatesData = {}, drillDownCoordinatesOptions = {}, cellData = {}) {\n\t\tif (!(typeof dimension === 'string')){\n\t\t\tthrow TypeError('The first argument must be instance of string')\n\t\t}\n\t\tif (!(\n\t\t\tisPlainObject(customMemberOptions)\n\t\t\t&& isPlainObject(rollupCoordinatesData)\n\t\t\t&& isPlainObject(drillDownCoordinatesOptions)\n\t\t\t&& isPlainObject(cellData)\n\t\t)){\n\t\t\tthrow TypeError('The arguments after the first must be plain objects')\n\t\t}\n\t\t\n\t\t// todo №1, а если члены с такими ключами уже существуют, нужнен варнинг, потому что, после десериализации член исчезнет, если не будут изменены значения ключевых полей\n\t\tconst rollupCoordinates = {};\n\t\tObject.keys(rollupCoordinatesData).forEach(dimension => {\n\t\t\tconst memberData = rollupCoordinatesData[dimension];\n\t\t\tconst memberList = this.getDimensionMembers(dimension);\n\t\t\tconst dimensionTable = getDimensionTreeByDimension.call(this, dimension).getTreeValue();\n\t\t\tconst { primaryKey } = dimensionTable;\n\t\t\tconst id = memberData[primaryKey];\n\t\t\tconst find = memberList.find(member => {\n\t\t\t\treturn id === dimensionTable.getMemberPrimaryKey(member)\n\t\t\t});\n\t\t\tif (!find) {\n\t\t\t\tthrow new InsufficientRollupData(dimension, id)\n\t\t\t} else {\n\t\t\t\trollupCoordinates[dimension] = find;\n\t\t\t}\n\t\t});\n\t\tconst dimensionTree = getDimensionTreeByDimension.call(this, dimension);\n\t\tconst childDimensionTrees = dimensionTree.getChildTrees();\n\t\tconst dimensionTable = dimensionTree.getTreeValue();\n\t\tconst { foreignKey } = dimensionTable;\n\t\tconst foreignKeysMemberData = {};\n\t\tchildDimensionTrees.forEach(childDimensionTree => {\n\t\t\tconst dimensionTable = childDimensionTree.getTreeValue();\n\t\t\tconst { dimension, foreignKey, primaryKey } = dimensionTable;\n\t\t\tconst member = rollupCoordinatesData[dimension];\n\t\t\tif (!member) {\n\t\t\t\tthrow new InsufficientRollupData(dimension)\n\t\t\t} else {\n\t\t\t\tforeignKeysMemberData[foreignKey] = member[primaryKey];\n\t\t\t}\n\t\t});\n\t\t// todo проверить, что customMemberOptions не содержит внешних ключей\n\t\tconst memberOptions = Object.assign({}, customMemberOptions, foreignKeysMemberData);\n\n\t\tlet saveMember = dimensionTree.createMember(memberOptions);\n\t\tlet saveIdAttribute = foreignKey;\n\t\tdimensionTree.traceUpOrder((tracedDimensionTable, tracedDimensionTree) => {\n\t\t\tif (dimensionTree !== tracedDimensionTree) {\n\t\t\t\tconst { dimension: parentDimension, foreignKey: parentIdAttribute } = tracedDimensionTable;\n\t\t\t\tconst drillDownCoordinatesData = { [ saveIdAttribute]: dimensionTable.getMemberPrimaryKey(saveMember) };\n\t\t\t\tObject.assign(drillDownCoordinatesData, drillDownCoordinatesOptions[parentDimension]);\n\t\t\t\tsaveMember = tracedDimensionTree.createMember(drillDownCoordinatesData);\n\t\t\t\tsaveIdAttribute = parentIdAttribute;\n\t\t\t}\n\t\t});\n\t\tthis.fillEmptyCells(cellData);\n\t}\n\t/**\n\t * @public\n\t * @param {string} dimension - dimension from which the member will be removed\n\t * @param {Member} member - the member will be removed\n\t * throw {TypeError}\n\t * */\n\tremoveDimensionMember(dimension, member) {\n\t\tif (!(typeof dimension === 'string')){\n\t\t\tthrow TypeError('The first argument must be instance of string')\n\t\t}\n\t\tif (!(member instanceof Member)){\n\t\t\tthrow TypeError('The second argument must be instance of Member')\n\t\t}\n\t\tconst dimensionTree = getDimensionTreeByDimension.call(this, dimension);\n\t\tconst endToBeRemoved = dimensionTree.removeProjectionOntoMember(member);\n\t\tconst cellTable = this.getCells();\n\t\tconst getRemoveMeasures = (dimension, members) => {\n\t\t\tconst removedCells = [];\n\t\t\tconst dimensionTable = dimensionTree.getDimensionTreeByDimension(dimension).getTreeValue();\n\t\t\tconst foreignKey = dimensionTable.foreignKey;\n\n\t\t\t// todo mapFilter похоже\n\t\t\tcellTable.forEach(cell => {\n\t\t\t\tmembers.forEach(member => {\n\t\t\t\t\tif (cell[foreignKey] == dimensionTable.getMemberPrimaryKey(member)) {\n\t\t\t\t\t\tremovedCells.push(cell)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t});\n\t\t\treturn removedCells;\n\t\t};\n\t\tObject.keys(endToBeRemoved).map(dimension => {\n\t\t\tconst removedMeasures = getRemoveMeasures(dimension, endToBeRemoved[dimension]);\n\t\t\tremovedMeasures.forEach(cell => {\n\t\t\t\tconst index = cellTable.indexOf(cell);\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\tcellTable.splice(index, 1);\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n\t/**\n\t * @public\n\t * @param {object|DimensionTree} dimensionHierarchy\n\t * @throw {TypeError}\n\t * */\n\taddDimensionHierarchy(dimensionHierarchy) {\n\t\tconst dimensionTree = DimensionTree.createDimensionTree(dimensionHierarchy);\n\t\tthis.dimensionHierarchies.push(\n\t\t\tdimensionTree\n\t\t);\n\t\tSnowflakeBuilder.anotherBuildOne(dimensionTree, this.getCells(), this.getCells(), this.getCells(), this.factPrimaryKey);\n\t}\n\t/**\n\t * @public\n\t * @param {DimensionTree} dimensionHierarchy\n\t * */\n\tremoveDimensionHierarchy(dimensionHierarchy) {\n\t\tif (!(dimensionHierarchy instanceof DimensionTree)){\n\t\t\tthrow TypeError('The argument must be instance of DimensionTree')\n\t\t}\n\t\t// first remove members\n\t\tSnowflakeBuilder.destroyDimensionTree(this.getCells(), this.getCells(), dimensionHierarchy, this);\n\t\t// then target dimension hierarchy\n\t\tthis.dimensionHierarchies.splice(this.dimensionHierarchies.indexOf(dimensionHierarchy), 1);\n\t}\n\t/**\n\t * @public\n\t * @return {EmptyCell[]}\n\t * @throw {TypeError}\n\t * */\n\tcreateEmptyCells(cellOptions = {}) {\n\t\tif (!isPlainObject(cellOptions)){\n\t\t\tthrow TypeError('Cell option argument must be a pure object')\n\t\t}\n\t\tconst emptyCells = [];\n\t\tconst tuples = Cube.cartesian(this);\n\t\ttuples.forEach(tuple => {\n\t\t\tconst unique = this.dice(tuple).getCells();\n\t\t\tif (!unique.length) {\n\t\t\t\tconst foreignKeysCellData = {};\n\t\t\t\tObject.keys(tuple).forEach(dimension => {\n\t\t\t\t\tconst dimensionTree = getDimensionTreeByDimension.call(this, dimension);\n\t\t\t\t\tconst dimensionTable = dimensionTree.getTreeValue();\n\t\t\t\t\tconst { foreignKey } = dimensionTable;\n\t\t\t\t\tforeignKeysCellData[foreignKey] = dimensionTable.getMemberPrimaryKey(tuple[dimension])\n\t\t\t\t});\n\t\t\t\tconst cellData = {\n\t\t\t\t\t...this.defaultFactOptions,\n\t\t\t\t\t...cellOptions,\n\t\t\t\t\t...foreignKeysCellData,\n\t\t\t\t};\n\t\t\t\t// todo нужна правеврка на то, что все свойства присутствуют, для этого нужна инф-ия о именах таких полей в схеме\n\t\t\t\tconst cell = EmptyCell.createEmptyCell(cellData);\n\t\t\t\temptyCells.push(cell);\n\t\t\t}\n\t\t});\n\t\treturn emptyCells;\n\t}\n\t/**\n\t * @public\n\t * @return {EmptyCell[]}\n\t * */\n\tgetEmptyCells() {\n\t\treturn this.getCells().filter(cell => EmptyCell.isEmptyCell(cell))\n\t}\n\t/**\n\t * @public\n\t * @param {Cell} cell\n\t * @return {boolean}\n\t * */\n\tisEmptyCell(cell) {\n\t\treturn EmptyCell.isEmptyCell(cell);\n\t}\n\t/**\n\t * @public\n\t * @param {EmptyCell[]} emptyCells\n\t * @throw {TypeError}\n\t * */\n\taddEmptyCells(emptyCells) {\n\t\tif (!Array.isArray(emptyCells)){\n\t\t\tthrow TypeError('The argument must be instance of Array')\n\t\t}\n\t\temptyCells.forEach((emptyCell, index) => {\n\t\t\tif (!this.isEmptyCell(emptyCell)) {\n\t\t\t\tthrow TypeError(`Some item in list of argument is not instances of EmptyCell, index: ${index}`)\n\t\t\t}\n\t\t});\n\t\t[].push.apply(this.getCells(), emptyCells);\n\t}\n\t/**\n\t * @public\n\t * Filling method for full size of cube\n\t * @param {object?} cellOptions - properties for empty cells\n\t * */\n\tfillEmptyCells(cellOptions) {\n\t\t// todo why here residuals? add test for that\n\t\tif (!residuals(this).length) {\n\t\t\tconst emptyCells = this.createEmptyCells(cellOptions);\n\t\t\tthis.addEmptyCells(emptyCells);\n\t\t}\n\t}\n\t/**\n\t * Check that the argument is an instance of SubCube\n\t * @return {boolean}\n\t * */\n\tisSubCube(){\n\t\treturn this instanceof SubCube;\n\t}\n\t/**\n\t * Cartesian product - list of all possible tuples\n\t * @param {Cube} cube\n\t * @return {Tuple[]}\n\t * */\n\tstatic cartesian(cube) {\n\t\tif (!(cube instanceof Cube)){\n\t\t\tthrow TypeError('The argument must be instance of Cube')\n\t\t}\n\t\tconst f = (a, b) => [].concat(...a.map(d => {\n\t\t\treturn b.map(e => {\n\t\t\t\treturn [].concat(d, e)\n\t\t\t})\n\t\t}));\n\t\t\n\t\tconst cartesian = (a, b, ...c) => {\n\t\t\treturn b ? cartesian(f(a, b), ...c) : a\n\t\t};\n\t\t\n\t\tconst dimensionsOrder = [];\n\t\t\n\t\tconst set = cube.dimensionHierarchies.map(dimensionTree => dimensionTree.getTreeValue()).map(dimensionTable => {\n\t\t\tdimensionsOrder.push(dimensionTable.dimension);\n\t\t\treturn dimensionTable.members;\n\t\t});\n\t\t\n\t\tconst tupleList = [];\n\t\t\n\t\tlet res;\n\t\tif (set.length) {\n\t\t\tif (set.length > 1) {\n\t\t\t\tres = cartesian.apply(null, set);\n\t\t\t} else {\n\t\t\t\tres = set[0].map(i => [i])\n\t\t\t}\n\t\t\tres.forEach(arr => {\n\t\t\t\tconst item = {};\n\t\t\t\tdimensionsOrder.forEach((dimension, index) => {\n\t\t\t\t\titem[dimension] = arr[index]\n\t\t\t\t});\n\t\t\t\ttupleList.push(new Tuple(item));\n\t\t\t\treturn item;\n\t\t\t});\n\t\t}\n\t\t\n\t\treturn tupleList;\n\t}\n}\n\n/**\n * SubCube is the target cube whose members are members of the source cube.\n * */\nclass SubCube extends Cube {\n\tconstructor({originalCube, previousCube, ...rest}){\n\t\tsuper(rest);\n\t\t/** link for chaining between operations */\n\t\tthis.originalCube = originalCube;\n\t\t/** link for chaining between operations */\n\t\tthis.previousCube = previousCube;\n\t}\n}\n\n/**\n * @this {Cube}\n * @return {DimensionHierarchy}\n * */\nfunction getHierarchy(hierarchy) {\n\treturn this.dimensionHierarchies.find(dimensionHierarchy => {\n\t\treturn dimensionHierarchy.getHierarchy() === hierarchy\n\t});\n}\n/**\n * @this {Cube}\n * @return {DimensionTree}\n * */\nfunction getDimensionTreeByDimension(dimension) {\n\tlet findDimensionTree;\n\tthis.dimensionHierarchies.forEach(dimensionTree => {\n\t\tconst searchedDimensionTree = dimensionTree.getDimensionTreeByDimension(dimension);\n\t\tif (searchedDimensionTree) {\n\t\t\tfindDimensionTree = dimensionTree.getDimensionTreeByDimension(dimension);\n\t\t}\n\t});\n\tif (!findDimensionTree) {\n\t\tthrow RangeError(`Not existed dimension: ${dimension}`);\n\t}\n\treturn findDimensionTree;\n}\n/**\n * @this {Cube}\n * @return {DimensionTree[]}\n * */\nfunction getDimensionTrees() {\n\treturn this.dimensionHierarchies.map(dimensionHierarchy => {\n\t\treturn dimensionHierarchy.getDimensionTree\n\t\t\t? dimensionHierarchy.getDimensionTree()\n\t\t\t: dimensionHierarchy\n\t})\n}\n/**\n * @private\n * Get facts from cube\n * */\nfunction denormalize(cells = this.getCells(), forSave = true) {\n\tconst data = SnowflakeBuilder.denormalize(cells, getDimensionTrees.call(this));\n\tif (forSave) {\n\t\tdata.forEach((data, index) => {\n\t\t\tif (cells[index] instanceof EmptyCell) {\n\t\t\t\tdelete data[this.factPrimaryKey];\n\t\t\t}\n\t\t})\n\t}\n\treturn data;\n}\n/**\n * @public\n * Residuals - list of tuples, according to which there is more than one member\n * @return {Tuple[]}\n * */\nfunction residuals(cube) {\n\tconst tuples = Cube.cartesian(cube);\n\tconst totalTuples = [];\n\ttuples.forEach(tuple => {\n\t\tconst partFacts = cube.dice(tuple).getFacts();\n\t\tif (partFacts.length > 1) {\n\t\t\ttotalTuples.push(tuple)\n\t\t}\n\t});\n\treturn totalTuples;\n}\n/**\n * Unfilled - list of tuples, in accordance with which there is not a single member\n * @@param {Cube} cube\n * */\nfunction unfilled(cube) {\n\tconst tuples = Cube.cartesian(cube);\n\tconst unfilled = [];\n\ttuples.forEach(tuple => {\n\t\tconst members = this.dice(tuple).getFacts(tuple);\n\t\tif (members.length === 0) {\n\t\t\tunfilled.push(tuple)\n\t\t}\n\t});\n\treturn unfilled;\n}\n\nfunction validateFactData(factPrimaryKey, factData){\n\tif (!factData.hasOwnProperty(factPrimaryKey)) {\n\t\tthrow new NotFoundFactId(factPrimaryKey)\n\t}\n}\n\nexport default Cube"],"names":["memory","InsufficientRollupData","dimension","id","message","NotFoundFactId","name","DimensionException","originalConsole","console","customConsole","string","warn","Fact","data","key","hasOwnProperty","value","type","error","handleError","Cell","EmptyCell","options","generateId","cell","replace","c","r","Math","random","toString","Member","Object","assign","this","InputMember","SnowflakeBuilder","factTable","cells","dimensionsTrees","cellTable","factPrimaryKey","forEach","dimensionTree","anotherBuildOne","tracePostOrder","dimensionTable","processDimension","getTreeValue","keyProps","otherProps","memberList","members","foreignKey","primaryKey","childIdAttributes","getChildTrees","map","childDimensions","totalMemberList","existMemberCount","length","args","entitiesParts","childIdAttribute","index","firstChildDimension","getDimensionTreeByDimension","memberListForFilter","mapFilter","countId","entitiesPart","membersData","entitiesArgs","push","keyIdMap","createKeyIdMap","apply","createMembersDataByKeyIdMap","part","find","etalon","member","entityPart","memberData","totalMemberListCount","startFrom","deleteProps","fact","props","prop","addMember","cellTables","cellTableFiltered","filter","getMemberPrimaryKey","restoredCache","indexOf","surrogateKey","createKeyFromProps","keys","createMemberData","concat","defaultData","propName","createdMemberData","obj","join","removedCells","dimensionHierarchies","cube","removedCell","splice","travers","removeMembers","bind","_this","restoreCell","dimensionTrees","facts","memberCopy","deleteMemberId","dicedCube","dice","getCells","removeMember","handlers","tracePreOrder","tracedDimensionTable","tracedDimensionTree","idValue","handler","DimensionTable","genericId","defaultMemberOptions","Error","log","memberOptions","linkProps","reduceId","createInputMember","reduce","acc","curValue","Tree","getParentTree","root","traceUpOrder","tracedTreeValue","tracedTree","isRoot","callback","parentTree","childTrees","treeValue","childTree","DimensionTree","level","parentNode","defineProperties","createDimensionTable","editable","enumerable","dimensionTreeData","validateDimensions","dimensions","tracedDimensionTreeValue","getRoot","search","dimensionTreeValue","newDimensionTreeByMember","cloneDimensionTreeWithoutMembers","projectDrillDown","projectDrillUp","projectDrill","traceMethodName","method","lastTracedMembers","lastTracedDimensionTree","tracedDimension","drillMembers","_this2","setMemberList","clone","clearMemberList","projectionDimensionTree","subtractDimensionTree","endToBeRemovedMember","dimensionProjection","membersProjection","toBeRemovedSpace","childMembers","childDimension","_this3","toBeAddedSpace","_this4","parentDimensionTable","parentMembers","parentMember","getMemberForeignKey","isExternal","childDimensionTable","childMember","createMember","newDimensionTree","DimensionHierarchy","activeDimension","hierarchy","createDimensionTree","dimensionHierarchy","Tuple","Space","newSpace","arguments","space","add","targetSpace","otherSpace","Array","prototype","isPlainObject","_typeof","undefined","call","getPrototypeOf","proto","Cube","TypeError","defaultFactOptions","createDimensionHierarchy","cellData","isEmptyCell","set","originalMultiset","isArray","RangeError","dimensionHierarchiesLength","projectionDimensionHierarchies","totalSpaces","dimensionTreeProjection","spacesForCells","searchedInTree","current","unionDimensionTree","union","filteredCellTable","cellBelongsToSpace","some","newDimensionHierarchies","originalDimensionHierarchy","finded","projectionDimensionHierarchy","createProxyDimensionTree","memberBelongToCells","filteredCell","removeProjectionOntoMember","SubCube","originalCube","previousCube","targetDimension","currentHierarchy","getHierarchy","hasDimension","setActiveDimension","forSave","denormalize","getDimensionTrees","_this6","factData","getFacts","anotherBuild","removeCells","destroy","customMemberOptions","rollupCoordinatesData","drillDownCoordinatesOptions","getDimensionMembers","childDimensionTrees","foreignKeysMemberData","childDimensionTree","saveMember","saveIdAttribute","parentDimension","parentIdAttribute","drillDownCoordinatesData","fillEmptyCells","endToBeRemoved","destroyDimensionTree","cellOptions","emptyCells","cartesian","tuple","foreignKeysCellData","createEmptyCell","emptyCell","tuples","totalTuples","createEmptyCells","addEmptyCells","a","b","d","e","dimensionsOrder","tupleList","i","arr","item","rest","findDimensionTree","getDimensionTree"],"mappings":"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"}